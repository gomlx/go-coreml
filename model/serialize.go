package model

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/google/uuid"
	"github.com/gomlx/go-coreml/proto/coreml/milspec"
	"github.com/gomlx/go-coreml/proto/coreml/spec"
	"google.golang.org/protobuf/proto"
)

// SpecVersion is the CoreML specification version.
// Version 9 supports ML Programs (MIL) with empty inputs (macOS 14+, iOS 17+).
const SpecVersion = 9

// SerializeOptions configures model serialization.
type SerializeOptions struct {
	// Author is the model author.
	Author string
	// ShortDescription is a brief description of the model.
	ShortDescription string
	// Version is the model version string.
	Version string
	// License is the model license.
	License string
}

// DefaultOptions returns default serialization options.
func DefaultOptions() SerializeOptions {
	return SerializeOptions{
		Author:           "go-coreml",
		ShortDescription: "Model generated by go-coreml",
		Version:          "1.0",
	}
}

// ToModel wraps a MIL program in a CoreML Model container.
func ToModel(program *milspec.Program, inputs, outputs []FeatureSpec, opts SerializeOptions) *spec.Model {
	// Build feature descriptions
	inputFeatures := make([]*spec.FeatureDescription, len(inputs))
	for i, inp := range inputs {
		inputFeatures[i] = &spec.FeatureDescription{
			Name:             inp.Name,
			ShortDescription: inp.Description,
			Type:             featureSpecToType(inp),
		}
	}

	outputFeatures := make([]*spec.FeatureDescription, len(outputs))
	for i, out := range outputs {
		outputFeatures[i] = &spec.FeatureDescription{
			Name:             out.Name,
			ShortDescription: out.Description,
			Type:             featureSpecToType(out),
		}
	}

	// Create model description
	description := &spec.ModelDescription{
		Input:  inputFeatures,
		Output: outputFeatures,
		Metadata: &spec.Metadata{
			Author:           opts.Author,
			ShortDescription: opts.ShortDescription,
			VersionString:    opts.Version,
			License:          opts.License,
		},
	}

	// Create model with MIL program
	model := &spec.Model{
		SpecificationVersion: SpecVersion,
		Description:          description,
		Type: &spec.Model_MlProgram{
			MlProgram: program,
		},
	}

	return model
}

// FeatureSpec describes an input or output feature.
type FeatureSpec struct {
	Name        string
	Description string
	DType       DType
	Shape       []int64
}

// featureSpecToType converts a FeatureSpec to a FeatureType.
func featureSpecToType(fs FeatureSpec) *spec.FeatureType {
	// Handle scalar (rank 0) tensors by representing them as shape [1]
	// CoreML ArrayFeatureType requires at least one dimension for shape constraints
	var shape []int64
	if len(fs.Shape) == 0 {
		shape = []int64{1}
	} else {
		shape = make([]int64, len(fs.Shape))
		copy(shape, fs.Shape)
	}

	// Map dtype to ArrayFeatureType_ArrayDataType
	var arrayDType spec.ArrayFeatureType_ArrayDataType
	switch fs.DType {
	case Float32:
		arrayDType = spec.ArrayFeatureType_FLOAT32
	case Float64:
		arrayDType = spec.ArrayFeatureType_DOUBLE
	case Int32:
		arrayDType = spec.ArrayFeatureType_INT32
	case Float16:
		arrayDType = spec.ArrayFeatureType_FLOAT16
	default:
		arrayDType = spec.ArrayFeatureType_FLOAT32
	}

	return &spec.FeatureType{
		Type: &spec.FeatureType_MultiArrayType{
			MultiArrayType: &spec.ArrayFeatureType{
				Shape:    shape,
				DataType: arrayDType,
			},
		},
	}
}

// SaveMLModel saves a Model to a .mlmodel file (uncompiled).
func SaveMLModel(model *spec.Model, path string) error {
	data, err := proto.Marshal(model)
	if err != nil {
		return fmt.Errorf("marshal model: %w", err)
	}

	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}

	return nil
}

// SaveMLPackage saves a Model to an .mlpackage directory.
// This format is required for ML Programs (MIL).
func SaveMLPackage(model *spec.Model, path string) error {
	// Create directory structure
	dataDir := filepath.Join(path, "Data", "com.apple.CoreML")
	weightsDir := filepath.Join(dataDir, "weights")

	if err := os.MkdirAll(weightsDir, 0755); err != nil {
		return fmt.Errorf("create directories: %w", err)
	}

	// Write model.mlmodel
	modelPath := filepath.Join(dataDir, "model.mlmodel")
	data, err := proto.Marshal(model)
	if err != nil {
		return fmt.Errorf("marshal model: %w", err)
	}

	if err := os.WriteFile(modelPath, data, 0644); err != nil {
		return fmt.Errorf("write model: %w", err)
	}

	// Write Manifest.json
	// The manifest uses UUIDs as keys for itemInfoEntries
	modelUUID := uuid.New().String()

	manifest := map[string]interface{}{
		"fileFormatVersion": "1.0.0",
		"itemInfoEntries": map[string]interface{}{
			modelUUID: map[string]interface{}{
				"author":      "com.apple.CoreML",
				"description": "CoreML Model Specification",
				"name":        "model.mlmodel",
				"path":        "com.apple.CoreML/model.mlmodel",
			},
		},
		"rootModelIdentifier": modelUUID,
	}

	manifestData, err := json.MarshalIndent(manifest, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal manifest: %w", err)
	}

	manifestPath := filepath.Join(path, "Manifest.json")
	if err := os.WriteFile(manifestPath, manifestData, 0644); err != nil {
		return fmt.Errorf("write manifest: %w", err)
	}

	return nil
}

// CompileModel compiles an .mlpackage to an .mlmodelc using coremlcompiler.
// This requires Xcode Command Line Tools to be installed.
func CompileModel(packagePath, outputPath string) error {
	// Use coremlcompiler to compile the model
	// xcrun coremlcompiler compile <input.mlpackage> <output_dir>
	// This is typically handled by the runtime, but can be called manually

	// For now, just check the paths exist
	if _, err := os.Stat(packagePath); err != nil {
		return fmt.Errorf("package not found: %w", err)
	}

	// The actual compilation is done by the bridge when loading
	// TODO: Add explicit compilation using xcrun coremlcompiler
	return nil
}
